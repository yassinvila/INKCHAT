<!DOCTYPE html>
<html>    
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
    <title>InkChat API</title>
    <style>
      body {
        margin: 0;
        min-height: 100vh;
        background: #0b0f14; /* your base background */
        overflow: hidden;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
      }

      /* ASCII background layer */
      #binary {
        transform: translate(-24px, -24px);
        width: calc(100vw + 48px);
        height: calc(100vh + 48px);
        position: fixed;
        inset: 0;
        z-index: 0;
        display: block;
        opacity: 0.28;
        pointer-events: none;
        white-space: pre;
        line-height: 1.05;
        font-size: 12px;
        color: #cfe3ff;
        /* “hole around cursor” 
        -webkit-mask-image: radial-gradient(
          circle 120px at var(--x, 50%) var(--y, 50%),
          transparent 0 20px,
          rgba(0,0,0,0.85) 20px,
          black 140px);
        mask-image: radial-gradient(
          circle 120px at var(--x, 50%) var(--y, 50%),
          transparent 0 20px,
          rgba(0,0,0,1) 20px,
          black 140px);
        */
      }

      #links {
        display: flex;
        gap: 22px;
        justify-content: center;
      }

      #links a {
        font-family: "Inter", sans-serif;
        color: #f2f6ff;
        text-decoration: none;
        letter-spacing: 0.12em;
        font-size: 24px;
        opacity: 0.9;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.12),
          0 0 2px rgba(0, 0, 0, 0.7);
      }

      /* LOGO */
      #content {
        position: relative;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #e7eef7;
        gap: 8px;
        z-index: 1;
      }

      #content pre {
        margin: 0;
        white-space: pre;
        line-height: 1.1;
        color: #f2f6ff;
        text-shadow: 0 0 14px rgba(255, 255, 255, 0.18),
          0 0 2px rgba(0, 0, 0, 0.7);
      }

      /* Logo line-by-line animation */
      #logo {
        display: block;
      }

      #logo .line {
        display: block;
        opacity: 0;
        transform: translateX(-20px);
        animation: lineAppear 0.3s ease-out forwards;
      }

      #logo .line:nth-child(1) { animation-delay: 0.1s; }
      #logo .line:nth-child(2) { animation-delay: 0.3s; }
      #logo .line:nth-child(3) { animation-delay: 0.5s; }
      #logo .line:nth-child(4) { animation-delay: 0.7s; }
      #logo .line:nth-child(5) { animation-delay: 0.9s; }
      #logo .line:nth-child(6) { animation-delay: 1.1s; }

      @keyframes lineAppear {
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      #links {
        opacity: 0;
        animation: fadeIn 0.5s ease-out 1.5s forwards;
      }

      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }
    </style>
  </head>

  <body>
    <pre id="binary"></pre>

    <div id="content">
      <pre id="logo"><span class="line">    ║██║███╗   ██╗██╗ ██╗                ██╗  ██╗ █████╗ ████████╗</span><span class="line">    ║██║████╗  ██║██║██╔╝  ╔══════════╗  ██║  ██║██╔══██╗╚══██╔══╝</span><span class="line">    ║██║██╔██╗ ██║█████╔   ║██████████║  ███████║███████║   ██║</span><span class="line">    ║██║██║╚██╗██║██╔██╗   ╚══════════╝  ██╔══██║██╔══██║   ██║</span><span class="line">    ║██║██║ ╚████║██║ ██╗                ██║  ██║██║  ██║   ██║</span><span class="line">    ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝                ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝</span></pre>

      <div id="links">
        <a href="api/health">HEALTH</a>
        <a href="api/mta">MTA</a>
        <a href="api/weather">WEATHER</a>
      </div>
    </div>

    <script>
      const binary = document.getElementById("binary");

      // Grid + cursor state
      let cols = 0, rows = 0;
      let grid = []; // array of strings
      let cursorCol = -9999, cursorRow = -9999;
      let rafPending = false;

      // EXACTLY 4 characters total -> 2x2 block
      const BOX_COLS = 0;
      const BOX_ROWS = 0;

      // Shift the erase block slightly right/down from the actual pointer
      const OFFSET_X_PX = 0;
      const OFFSET_Y_PX = 1;

      // Must match CSS overscan (translate -24px, -24px and +48px size)
      const OVERSCAN_PX = 48;

      // "Rain" state: per-column speed + accumulator for uneven falling
      let colSpeed = [];   // each column: how often it advances (frames)
      let colAcc = [];     // each column: accumulator
      let timerId = null;
      let tickMs = 75;     // base tick (overall smoothness)

      function measureChar() {
        const probe = document.createElement("span");
        const cs = getComputedStyle(binary);

        probe.textContent = "0";
        probe.style.position = "fixed";
        probe.style.left = "-9999px";
        probe.style.top = "-9999px";
        probe.style.visibility = "hidden";
        probe.style.fontFamily = cs.fontFamily;
        probe.style.fontSize = cs.fontSize;
        probe.style.lineHeight = cs.lineHeight;
        probe.style.whiteSpace = "pre";

        document.body.appendChild(probe);
        const rect = probe.getBoundingClientRect();
        probe.remove();

        return { w: rect.width || 1, h: rect.height || 1 };
      }

      function randBit() {
        return Math.random() < 0.5 ? "0" : "1";
      }

      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function initRain() {
        colSpeed = new Array(cols);
        colAcc = new Array(cols);

        for (let c = 0; c < cols; c++) {
          // lower = faster, higher = slower
          // These are "advance every N ticks"
          colSpeed[c] = randInt(1, 6);
          colAcc[c] = 0;
        }
      }

      function buildGrid() {
        const { w, h } = measureChar();

        cols = Math.ceil((window.innerWidth + OVERSCAN_PX) / w) + 2;
        rows = Math.ceil((window.innerHeight + OVERSCAN_PX) / h) + 2;

        grid = new Array(rows);
        for (let r = 0; r < rows; r++) {
          let line = "";
          for (let c = 0; c < cols; c++) line += randBit();
          grid[r] = line;
        }

        initRain();
        render();
      }

      
      function render() {
        const cStart = cursorCol;
        const rStart = cursorRow;

        let out = "";

        for (let r = 0; r < rows; r++) {
          // fast path: rows outside the 2-row erase block
          if (r < rStart || r >= rStart + BOX_ROWS) {
            out += grid[r] + "\n";
            continue;
          }

          const base = grid[r];
          let rowArr = base.split("");

          // erase 2 columns in this row (2x2 total across 2 rows)
          for (let c = cStart; c < cStart + BOX_COLS; c++) {
            if (c >= 0 && c < cols) rowArr[c] = " ";
          }

          out += rowArr.join("") + "\n";
        }

        binary.textContent = out;
      }

      function scheduleRender() {
        if (rafPending) return;
        rafPending = true;
        requestAnimationFrame(() => {
          rafPending = false;
          render();
        });
      }

      function shiftColumnsDown() {
        if (!rows || !cols) return;

        // Convert each row to a mutable array once
        const mat = new Array(rows);
        for (let r = 0; r < rows; r++) mat[r] = grid[r].split("");

        // For each column, decide if it advances this tick
        for (let c = 0; c < cols; c++) {
          colAcc[c] += 1;

          if (colAcc[c] < colSpeed[c]) continue;
          colAcc[c] = 0;

          // take bottom char, move it to top, shift everything down
          const bottom = mat[rows - 1][c];

          for (let r = rows - 1; r > 0; r--) {
            mat[r][c] = mat[r - 1][c];
          }

          // new top char: sometimes wrap bottom, sometimes spawn fresh bit for variety
          mat[0][c] = Math.random() < 0.65 ? randBit() : bottom;

          // occasionally change speed so it feels alive
          if (Math.random() < 0.01) {
            colSpeed[c] = randInt(1, 7);
          }
        }

        // Rebuild grid strings
        for (let r = 0; r < rows; r++) grid[r] = mat[r].join("");
      }

      function startRain() {
        if (timerId) clearInterval(timerId);
        timerId = setInterval(() => {
          shiftColumnsDown();
          scheduleRender();
        }, tickMs);
      }

      function setCursor(e) {
        const rect = binary.getBoundingClientRect();

        // Because #binary is overscanned and translated -24px,-24px,
        // rect.left/top are negative; this math still correctly maps.
        const x = e.clientX - rect.left + OFFSET_X_PX;
        const y = e.clientY - rect.top + OFFSET_Y_PX;

        const { w, h } = measureChar();

        cursorCol = Math.floor(x / w);
        cursorRow = Math.floor(y / h);

        scheduleRender();
      }

      window.addEventListener("mousemove", setCursor);

      window.addEventListener(
        "touchmove",
        (e) => {
          const t = e.touches[0];
          setCursor(t);
        },
        { passive: true }
      );

      window.addEventListener("resize", () => {
        buildGrid();
        startRain();
      });

      buildGrid();
      startRain();
    </script>
  </body>
</html>
